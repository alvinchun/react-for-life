{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\\\uD55C\\uAD11\\uD76C\\\\Desktop\\\\React\\\\react-for-life\\\\frontend\\\\src\\\\UseCallback.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect, useMemo, useCallback } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const UseCallback = () => {\n  _s();\n\n  const [number, setNumber] = useState(0);\n  /*\r\n      자바스크립트는 두가지 type으로 나뉜다.\r\n      원시타입 (primitive) vs 객체타입 (object)\r\n      \r\n      원시타입은 변수라는 상자에 바로 저장되지만\r\n      객체타입은 너무 커서 메모리상의 공간이 할당되서 그곳에 저장된다. 객체의 변수에는 객체가 담긴 메모리의 주소가 할당이 된다.\r\n      */\n\n  const someFunction = useCallback(() => {\n    console.log(`someFunc: number: ${number}`);\n    return;\n  }); // 원시타입인 number(state)가 변화하면서 UseCallback 함수형컴포넌트가 리렌더링 된다. 리랜더링이 되면서 useEffect에서 객체타입인 함수는 불려질때마다 항상 다른 주소로 저장이 되면서 또 다른 메모리 공간에 저장이 되면서 콜스택이 쌓인다.\n\n  useEffect(() => {\n    console.log('someFunction이 변경되었습니다.');\n  }, [someFunction]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"number\",\n      value: number,\n      onChange: e => setNumber(e.target.value)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: someFunction,\n      children: \"Call someFunc\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 5\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 27,\n    columnNumber: 5\n  }, this);\n};\n\n_s(UseCallback, \"NGa476TTLB1xWovnOTrN2XevqA4=\");\n\n_c = UseCallback;\n\nvar _c;\n\n$RefreshReg$(_c, \"UseCallback\");","map":{"version":3,"sources":["C:/Users/한광희/Desktop/React/react-for-life/frontend/src/UseCallback.js"],"names":["React","useState","useEffect","useMemo","useCallback","UseCallback","number","setNumber","someFunction","console","log","e","target","value"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,EAAqCC,OAArC,EAA8CC,WAA9C,QAAiE,OAAjE;;AAEA,OAAO,MAAMC,WAAW,GAAG,MAAM;AAAA;;AAE7B,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBN,QAAQ,CAAC,CAAD,CAApC;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE,QAAMO,YAAY,GAAGJ,WAAW,CAAC,MAAM;AACrCK,IAAAA,OAAO,CAACC,GAAR,CAAa,qBAAoBJ,MAAO,EAAxC;AACA;AACD,GAH+B,CAAhC,CAZ+B,CAiBjC;;AAEEJ,EAAAA,SAAS,CAAC,MAAM;AACdO,IAAAA,OAAO,CAACC,GAAR,CAAY,wBAAZ;AACD,GAFQ,EAEP,CAACF,YAAD,CAFO,CAAT;AAIA,sBACE;AAAA,4BAEA;AAAO,MAAA,IAAI,EAAC,QAAZ;AACA,MAAA,KAAK,EAAEF,MADP;AAEA,MAAA,QAAQ,EAAGK,CAAD,IAAOJ,SAAS,CAACI,CAAC,CAACC,MAAF,CAASC,KAAV;AAF1B;AAAA;AAAA;AAAA;AAAA,YAFA,eAMA;AAAA;AAAA;AAAA;AAAA,YANA,eAQA;AAAQ,MAAA,OAAO,EAAEL,YAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YARA;AAAA;AAAA;AAAA;AAAA;AAAA,UADF;AAYD,CAnCM;;GAAMH,W;;KAAAA,W","sourcesContent":["import React, { useState, useEffect, useMemo, useCallback } from 'react'\r\n\r\nexport const UseCallback = () => {\r\n\r\n    const [number, setNumber] = useState(0);\r\n\r\n/*\r\n    자바스크립트는 두가지 type으로 나뉜다.\r\n    원시타입 (primitive) vs 객체타입 (object)\r\n    \r\n    원시타입은 변수라는 상자에 바로 저장되지만\r\n    객체타입은 너무 커서 메모리상의 공간이 할당되서 그곳에 저장된다. 객체의 변수에는 객체가 담긴 메모리의 주소가 할당이 된다.\r\n    */\r\n  \r\n  const someFunction = useCallback(() => {\r\n    console.log(`someFunc: number: ${number}`);\r\n    return;\r\n  })\r\n  \r\n// 원시타입인 number(state)가 변화하면서 UseCallback 함수형컴포넌트가 리렌더링 된다. 리랜더링이 되면서 useEffect에서 객체타입인 함수는 불려질때마다 항상 다른 주소로 저장이 되면서 또 다른 메모리 공간에 저장이 되면서 콜스택이 쌓인다.\r\n  \r\n  useEffect(() => {\r\n    console.log('someFunction이 변경되었습니다.');\r\n  },[someFunction])\r\n\r\n  return (\r\n    <div>\r\n\r\n    <input type=\"number\" \r\n    value={number} \r\n    onChange={(e) => setNumber(e.target.value)}/>\r\n    \r\n    <br />\r\n      \r\n    <button onClick={someFunction}>Call someFunc</button>\r\n    </div>\r\n  )\r\n}"]},"metadata":{},"sourceType":"module"}